# gRPC Tutorial

> Simple gRPC service written in Go with steps to reproduce

All the steps have corresponding commits in the repo to track how application evolves.
This readme highlights only the most interesting parts of every step, all the details are available in corresponding commits.

Index:
- [1. Hello world go application](#1-hello-world-go-application)
- [2. gRPC service definition and basic Makefile](#2-grpc-service-definition-and-basic-makefile)
- [3. Implement EchoService Server](#3-implement-echoservice-server)
- [4. Wrap application into simple command-based approach](#4-wrap-application-into-simple-command-based-approach)
- [5. Create simple gRPC Server, finally!](#5-create-simple-grpc-server-finally)
  - [gRPC Server testing tools](#grpc-server-testing-tools)

## 1. Hello world go application

```
go mod init
touch main.go
```

`main.go` contents:

```go
package main

import "fmt"

func main() {
	fmt.Println("Welcome to the gRPC Tutorial!")
}
```

## 2. gRPC service definition and basic Makefile

Define simple `Echo` service and its corresponding types in `proto/echo.proto` file.

```proto
syntax = "proto3";

package rpc;

import "google/protobuf/timestamp.proto";

message SaySomething {
    string Message = 1;
}

message HearBack {
    string Message = 1;
    google.protobuf.Timestamp HappenedAt = 2;
}

service EchoService {
    rpc Reflect (SaySomething) returns (HearBack);
}
```

Create simple `Makefile` with only two tasks defined at the moment
- `deps` for installing required dependencies
- `proto` for generating go code from protobuf definition 

Lines that worth looking at are `package rpc;` in the protobuf definition and `--go_out=plugins=grpc:pkg/rpc`
in the `proto` task - go package name must match package name in protobuf definition, so in this tutorial app
it is going to be located at `github.com/vgarvardt/grpc-tutorial/pkg/rpc`.

Another interesting thing is `import "google/protobuf/timestamp.proto";` and `google.protobuf.Timestamp HappenedAt = 2;`
that is basically custom protobuf type that we're going to use.

There are at least two ways of working with generated code - it can be generated in the codebase and pushed to a repository
or generated by a CI task before application will be build. Both ways have pros and cons and it is up to developers to choose
the way they want to follow. For this tutorial I'll be storing generated file in the repo.
 
Do not forget to update all the package used by existing project by running `go mod vendor`.

## 3. Implement EchoService Server

Time to look into code generated from protobuf definition. It has the following parts:
- struct types for messages with fields for internal usage
- `EchoServiceClient` interface and implementation
- `EchoServiceServer` interface w/out implementation
- `RegisterEchoServiceServer` function that accepts `EchoServiceServer`

We will start from the server interface implementation.

As I'm going to use this tutorial repository for several different applications I'm going to organise small monorepo here.
All the shared code will be stored in `pkg` package on the top level, all applications will be stored in `app/<application>`
packages with all private dependencies stored in `internal` sub-package to make them really private.

Start with `mkdir -p app/echo/internal/service && touch app/echo/internal/service/echo.go`.

Here is the full listing of the service server:

```go
package service

import (
	"context"

	"github.com/golang/protobuf/ptypes"
	"github.com/vgarvardt/grpc-tutorial/pkg/rpc"
)

type echoServiceServer struct{}

// NewEchoServiceServer builds and returns is rpc.EchoServiceServer implementation
func NewEchoServiceServer() *echoServiceServer {
	return &echoServiceServer{}
}

// Reflect is the rpc.EchoServiceServer implementation
func (s *echoServiceServer) Reflect(ctx context.Context, in *rpc.SaySomething) (*rpc.HearBack, error) {
	return &rpc.HearBack{
		Message:    in.Message,
		HappenedAt: ptypes.TimestampNow(),
	}, nil
}

```

It starts with struct type for a service. Since it is going to be interface implementation it does not make sense to expose
the type, it should be built using the builder function. The implementation of the only method is simple - get the message
from the input and current timestamp.

## 4. Wrap application into simple command-based approach

Applications are going to be organised as monorepo so it also can be build as a single application working in different modes.
I'll use `github.com/spf13/cobra` to organise it.

First of all I'm going to create a root command that will be used to attach different commands/modes to it.
Start with `touch app/root.go` and add the following content to it:

```go
package app

import (
	"github.com/spf13/cobra"
)

// NewRootCmd creates a new instance of the root command
func NewRootCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "grpc-tutorial",
		Short: "gRPC Tutorial is the set of simple apps to play with gRPC in go",
	}

	return cmd
}

```

Do nt forget to run `go mod vendor` to let go modules add missing package to a project.

Now we can add the first command - let it be `version` as it does not require any logic. Do the `touch app/version.go`
and add the following content to it:

```go
package app

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
)

var version = "0.0.0-dev"

// NewVersionCmd creates a new version command
func NewVersionCmd(ctx context.Context) *cobra.Command {
	return &cobra.Command{
		Use:     "version",
		Short:   "Print the version information",
		Aliases: []string{"v"},
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Printf("grpc-tutorial %s\n", version)
		},
	}
}
```

Variable `version` is declared as private and has predefined default value. It allows to define real application version
in compile-time in CI.

Now it is time to register the first command in the root, so the root command builder function will look like this:

```go
// NewRootCmd creates a new instance of the root command
func NewRootCmd() *cobra.Command {
	ctx := context.Background()

	cmd := &cobra.Command{
		Use:   "grpc-tutorial",
		Short: "gRPC Tutorial is the set of simple apps to play with gRPC in go",
	}

	cmd.AddCommand(NewVersionCmd(ctx))

	return cmd
}
```

And now it is time to use the root command as an entry point for the application.
To do this we need to change the `main()` function, so the full contents of the `main.go` will be:

```go
package main

import (
	"log"

	"github.com/vgarvardt/grpc-tutorial/app"
)

func main() {
	rootCmd := app.NewRootCmd()

	if err := rootCmd.Execute(); err != nil {
		log.Fatalf("Failed to run command: %v\n", err)
	}
}
```

And finally we can test the application

```bash
$ go run main.go version
grpc-tutorial 0.0.0-dev
```

## 5. Create simple gRPC Server, finally!

All preparations are done, nothing holds us from creating an gRPC Server! Do the `touch app/echo/app.go` and add the
following contents to it:

```go
package echo

import (
	"context"
	"fmt"
	"log"
	"net"

	"github.com/pkg/errors"
	"github.com/spf13/cobra"
	"google.golang.org/grpc"
	"google.golang.org/grpc/reflection"

	"github.com/vgarvardt/grpc-tutorial/app/echo/internal/service"
	"github.com/vgarvardt/grpc-tutorial/pkg/rpc"
)

const tcpPort = 5000

// NewServerCmd builds new echo-server command
func NewServerCmd(ctx context.Context, version string) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "echo-server",
		Short: "Starts Echo gRPC Server",
		RunE: func(cmd *cobra.Command, args []string) error {
			return RunServer(ctx, version)
		},
	}

	return cmd
}

// RunServer is the run command to start echo-server
func RunServer(ctx context.Context, version string) error {
	log.Printf("Starting echo-server v%s", version)

	// create new gRPC Server instance
	s := grpc.NewServer()

	// create new service server instance
	srv := service.NewEchoServiceServer()

	// register service in gRPC Server
	rpc.RegisterEchoServiceServer(s, srv)

	// register server reflection to help tools interact with the server
	reflection.Register(s)

	// create TCP listener
	tcpListener, err := net.Listen("tcp", fmt.Sprintf(":%d", tcpPort))
	if err != nil {
		return errors.Wrap(err, "could not start TCP listener")
	}

	log.Printf("Running gRPC server on port %d...\n", tcpPort)
	if err := s.Serve(tcpListener); err != nil {
		return errors.Wrap(err, "failed to server gRPC server")
	}

	return nil
}
```

Almost all lines are commented here and should be pretty easy to understand. The only line that can be unclear is
`reflection.Register(s)` and I'll explain it a bit later in this section.

The command is ready, now need to register it in the root one with `cmd.AddCommand(echo.NewServerCmd(ctx, version))`
right after the `version` one and gRPC Server is ready for the first test!

```
$ go run main.go echo-server
2019/08/21 23:09:24 Starting echo-server v0.0.0-dev
2019/08/21 23:09:24 Running gRPC server on port 5000...
```

### gRPC Server testing tools

Now that we have gRPC server up and running it would be nice to test it somehow. For HTTP-based API `Postman` or `curl`
can be used, but they are useless when it comes to gRPC. Luckily there are more or less similar tools to make gRPC calls.
I tried two of them:
- [`grpcui`](https://github.com/fullstorydev/grpcui) - GUI one with web interface
- [`grpcurl`](https://github.com/fullstorydev/grpcurl) - CLI curl-like one

There are two ways of using these tools - either you need to provide a protobuf definition file so it could get the
information about the server and types it is going to work with (same as we generated go file out of it), or it can get
the all the required information from the server in the runtime and this is where gRPC Reflection comes into play,
the one that we enabled with `reflection.Register(s)`.

Here are examples of using the tools:

```bash
$ grpcui -plaintext localhost:5000
gRPC Web UI available at http://127.0.0.1:57917/...
```

```
$ grpcurl -plaintext localhost:5000 list
grpc.reflection.v1alpha.ServerReflection
rpc.EchoService

$ grpcurl -plaintext localhost:5000 describe rpc.EchoService
rpc.EchoService is a service:
service EchoService {
  rpc Reflect ( .rpc.SaySomething ) returns ( .rpc.HearBack );
}

$ grpcurl -plaintext -d '{"Message": "Hello from gRPCurl"}' localhost:5000 rpc.EchoService/Reflect
{
  "Message": "Hello from gRPCurl",
  "HappenedAt": "2019-08-22T08:09:02.061941Z"
}

```

One parameter worth mentioning here is the `-plaintext` that we have to set in both tools - it enables
insecure connection mode. I'll cover security part a bit further. For now just keep in mind - Server is running
in insecure mode and is not ready for production usage.
