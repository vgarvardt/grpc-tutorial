# gRPC Tutorial

> Simple gRPC service written in Go with steps to reproduce

All the steps have corresponding commits in the repo to track how application evolves.
This readme highlights only the most interesting parts of every step, all the details are available in corresponding commits.

## 1. Hello world go application

```
go mod init
touch main.go
```

`main.go` contents:

```go
package main

import "fmt"

func main() {
	fmt.Println("Welcome to the gRPC Tutorial!")
}
```

## 2. gRPC service definition and basic Makefile

Define simple `Echo` service and its corresponding types in `proto/echo.proto` file.

```proto
syntax = "proto3";

package rpc;

import "google/protobuf/timestamp.proto";

message SaySomething {
    string Message = 1;
}

message HearBack {
    string Message = 1;
    google.protobuf.Timestamp HappenedAt = 2;
}

service EchoService {
    rpc Reflect (SaySomething) returns (HearBack);
}
```

Create simple `Makefile` with only two tasks defined at the moment
- `deps` for installing required dependencies
- `proto` for generating go code from protobuf definition 

Lines that worth looking at are `package rpc;` in the protobuf definition and `--go_out=plugins=grpc:pkg/rpc`
in the `proto` task - go package name must match package name in protobuf definition, so in this tutorial app
it is going to be located at `github.com/vgarvardt/grpc-tutorial/pkg/rpc`.

Another interesting thing is `import "google/protobuf/timestamp.proto";` and `google.protobuf.Timestamp HappenedAt = 2;`
that is basically custom protobuf type that we're going to use. There are 

There are at least two ways of working with generated code - it can be generated in the codebase and pushed to a repository
or generated by a CI task before application will be build. Both ways have pros and cons and it is up to developers to choose
the way they want to follow. For this tutorial I'll be storing generated file in the repo.
 
Do not forget to update all the package used by existing project by running `go mod vendor`.
