# gRPC Tutorial

> Simple gRPC service written in Go with steps to reproduce

All the steps have corresponding commits in the repo to track how application evolves.
This readme highlights only the most interesting parts of every step, all the details are available in corresponding commits.

Index:
- [1. Hello world go application](#1-hello-world-go-application)
- [2. gRPC service definition and basic Makefile](#2-grpc-service-definition-and-basic-makefile)
- [3. Implement EchoService Server](#3-implement-echoservice-server)

## 1. Hello world go application

```
go mod init
touch main.go
```

`main.go` contents:

```go
package main

import "fmt"

func main() {
	fmt.Println("Welcome to the gRPC Tutorial!")
}
```

## 2. gRPC service definition and basic Makefile

Define simple `Echo` service and its corresponding types in `proto/echo.proto` file.

```proto
syntax = "proto3";

package rpc;

import "google/protobuf/timestamp.proto";

message SaySomething {
    string Message = 1;
}

message HearBack {
    string Message = 1;
    google.protobuf.Timestamp HappenedAt = 2;
}

service EchoService {
    rpc Reflect (SaySomething) returns (HearBack);
}
```

Create simple `Makefile` with only two tasks defined at the moment
- `deps` for installing required dependencies
- `proto` for generating go code from protobuf definition 

Lines that worth looking at are `package rpc;` in the protobuf definition and `--go_out=plugins=grpc:pkg/rpc`
in the `proto` task - go package name must match package name in protobuf definition, so in this tutorial app
it is going to be located at `github.com/vgarvardt/grpc-tutorial/pkg/rpc`.

Another interesting thing is `import "google/protobuf/timestamp.proto";` and `google.protobuf.Timestamp HappenedAt = 2;`
that is basically custom protobuf type that we're going to use.

There are at least two ways of working with generated code - it can be generated in the codebase and pushed to a repository
or generated by a CI task before application will be build. Both ways have pros and cons and it is up to developers to choose
the way they want to follow. For this tutorial I'll be storing generated file in the repo.
 
Do not forget to update all the package used by existing project by running `go mod vendor`.

## 3. Implement EchoService Server

Time to look into code generated from protobuf definition. It has the following parts:
- struct types for messages with fields for internal usage
- `EchoServiceClient` interface and implementation
- `EchoServiceServer` interface w/out implementation
- `RegisterEchoServiceServer` function that accepts `EchoServiceServer`

We will start from the server interface implementation.

As I'm going to use this tutorial repository for several different applications I'm going to organise small monorepo here.
All the shared code will be stored in `pkg` package on the top level, all applications will be stored in `app/<application>`
packages with all private dependencies stored in `internal` sub-package to make them really private.

Start with `mkdir -p app/echo/internal/service && touch app/echo/internal/service/echo.go`.

Here is the full listing of the service server:

```go
package service

import (
	"context"

	"github.com/golang/protobuf/ptypes"
	"github.com/vgarvardt/grpc-tutorial/pkg/rpc"
)

type echoServiceServer struct{}

// NewEchoServiceServer builds and returns is rpc.EchoServiceServer implementation
func NewEchoServiceServer() *echoServiceServer {
	return &echoServiceServer{}
}

// Reflect is the rpc.EchoServiceServer implementation
func (s *echoServiceServer) Reflect(ctx context.Context, in *rpc.SaySomething) (*rpc.HearBack, error) {
	return &rpc.HearBack{
		Message:    in.Message,
		HappenedAt: ptypes.TimestampNow(),
	}, nil
}

```

It starts with struct type for a service. Since it is going to be interface implementation it does not make sense to expose
the type, it should be built using the builder function. The implementation of the only method is simple - get the message
from the input and current timestamp.
