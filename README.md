# gRPC Tutorial

> Simple gRPC service written in Go with steps to reproduce

All the steps have corresponding commits in the repo to track how application evolves.
This readme highlights only the most interesting parts of every step, all the details are available in corresponding commits.

Index:
- [1. Hello world go application](#1-hello-world-go-application)
- [2. gRPC service definition and basic Makefile](#2-grpc-service-definition-and-basic-makefile)
- [3. Implement EchoService Server](#3-implement-echoservice-server)
- [4. Wrap application into simple command-based approach](#4-wrap-application-into-simple-command-based-approach)

## 1. Hello world go application

```
go mod init
touch main.go
```

`main.go` contents:

```go
package main

import "fmt"

func main() {
	fmt.Println("Welcome to the gRPC Tutorial!")
}
```

## 2. gRPC service definition and basic Makefile

Define simple `Echo` service and its corresponding types in `proto/echo.proto` file.

```proto
syntax = "proto3";

package rpc;

import "google/protobuf/timestamp.proto";

message SaySomething {
    string Message = 1;
}

message HearBack {
    string Message = 1;
    google.protobuf.Timestamp HappenedAt = 2;
}

service EchoService {
    rpc Reflect (SaySomething) returns (HearBack);
}
```

Create simple `Makefile` with only two tasks defined at the moment
- `deps` for installing required dependencies
- `proto` for generating go code from protobuf definition 

Lines that worth looking at are `package rpc;` in the protobuf definition and `--go_out=plugins=grpc:pkg/rpc`
in the `proto` task - go package name must match package name in protobuf definition, so in this tutorial app
it is going to be located at `github.com/vgarvardt/grpc-tutorial/pkg/rpc`.

Another interesting thing is `import "google/protobuf/timestamp.proto";` and `google.protobuf.Timestamp HappenedAt = 2;`
that is basically custom protobuf type that we're going to use.

There are at least two ways of working with generated code - it can be generated in the codebase and pushed to a repository
or generated by a CI task before application will be build. Both ways have pros and cons and it is up to developers to choose
the way they want to follow. For this tutorial I'll be storing generated file in the repo.
 
Do not forget to update all the package used by existing project by running `go mod vendor`.

## 3. Implement EchoService Server

Time to look into code generated from protobuf definition. It has the following parts:
- struct types for messages with fields for internal usage
- `EchoServiceClient` interface and implementation
- `EchoServiceServer` interface w/out implementation
- `RegisterEchoServiceServer` function that accepts `EchoServiceServer`

We will start from the server interface implementation.

As I'm going to use this tutorial repository for several different applications I'm going to organise small monorepo here.
All the shared code will be stored in `pkg` package on the top level, all applications will be stored in `app/<application>`
packages with all private dependencies stored in `internal` sub-package to make them really private.

Start with `mkdir -p app/echo/internal/service && touch app/echo/internal/service/echo.go`.

Here is the full listing of the service server:

```go
package service

import (
	"context"

	"github.com/golang/protobuf/ptypes"
	"github.com/vgarvardt/grpc-tutorial/pkg/rpc"
)

type echoServiceServer struct{}

// NewEchoServiceServer builds and returns is rpc.EchoServiceServer implementation
func NewEchoServiceServer() *echoServiceServer {
	return &echoServiceServer{}
}

// Reflect is the rpc.EchoServiceServer implementation
func (s *echoServiceServer) Reflect(ctx context.Context, in *rpc.SaySomething) (*rpc.HearBack, error) {
	return &rpc.HearBack{
		Message:    in.Message,
		HappenedAt: ptypes.TimestampNow(),
	}, nil
}

```

It starts with struct type for a service. Since it is going to be interface implementation it does not make sense to expose
the type, it should be built using the builder function. The implementation of the only method is simple - get the message
from the input and current timestamp.

## 4. Wrap application into simple command-based approach

Applications are going to be organised as monorepo so it also can be build as a single application working in different modes.
I'll use `github.com/spf13/cobra` to organise it.

First of all I'm going to create a root command that will be used to attach different commands/modes to it.
Start with `touch app/root.go` and add the following content to it:

```go
package app

import (
	"github.com/spf13/cobra"
)

// NewRootCmd creates a new instance of the root command
func NewRootCmd() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "grpc-tutorial",
		Short: "gRPC Tutorial is the set of simple apps to play with gRPC in go",
	}

	return cmd
}

```

Do nt forget to run `go mod vendor` to let go modules add missing package to a project.

Now we can add the first command - let it be `version` as it does not require any logic. Do the `touch app/version.go`
and add the following content to it:

```go
package app

import (
	"context"
	"fmt"

	"github.com/spf13/cobra"
)

var version = "0.0.0-dev"

// NewVersionCmd creates a new version command
func NewVersionCmd(ctx context.Context) *cobra.Command {
	return &cobra.Command{
		Use:     "version",
		Short:   "Print the version information",
		Aliases: []string{"v"},
		Run: func(cmd *cobra.Command, args []string) {
			fmt.Printf("grpc-tutorial %s\n", version)
		},
	}
}
```

Variable `version` is declared as private and has predefined default value. It allows to define real application version
in compile-time in CI.

Now it is time to register the first command in the root, so the root command builder function will look like this:

```go
// NewRootCmd creates a new instance of the root command
func NewRootCmd() *cobra.Command {
	ctx := context.Background()

	cmd := &cobra.Command{
		Use:   "grpc-tutorial",
		Short: "gRPC Tutorial is the set of simple apps to play with gRPC in go",
	}

	cmd.AddCommand(NewVersionCmd(ctx))

	return cmd
}
```

And now it is time to use the root command as an entry point for the application.
To do this we need to change the `main()` function, so the full contents of the `main.go` will be:

```go
package main

import (
	"log"

	"github.com/vgarvardt/grpc-tutorial/app"
)

func main() {
	rootCmd := app.NewRootCmd()

	if err := rootCmd.Execute(); err != nil {
		log.Fatalf("Failed to run command: %v\n", err)
	}
}
```

And finally we can test the application

```bash
$ go run main.go version
grpc-tutorial 0.0.0-dev
```
